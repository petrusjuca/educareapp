import 'dart:async';
import 'dart:convert' show utf8;
import 'dart:io' show Platform;

import 'package:flutter/material.dart';
import 'package:flutter_blue_plus/flutter_blue_plus.dart';
import 'package:permission_handler/permission_handler.dart';

void main() {
  FlutterBluePlus.setLogLevel(LogLevel.verbose, color: true);
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) => const MaterialApp(
        home: BluetoothScreen(),
        debugShowCheckedModeBanner: false,
      );
}

class BluetoothScreen extends StatefulWidget {
  const BluetoothScreen({super.key});
  @override
  State<BluetoothScreen> createState() => _BluetoothScreenState();
}

class _BluetoothScreenState extends State<BluetoothScreen> {
  BluetoothDevice? targetDevice;
  BluetoothCharacteristic? targetCharacteristic;

  StreamSubscription<List<ScanResult>>? scanResultsSub;
  StreamSubscription<BluetoothConnectionState>? deviceStateSub;
  StreamSubscription<List<int>>? notifySub;

  String received = "";
  bool isConnected = false;
  bool scanning = false;

  final String deviceName = "EDUCARE";
  final int scanTimeoutSeconds = 8;
  final int maxRetries = 4;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _ensureConnectedFlow();
    });
  }

  @override
  void dispose() {
    scanResultsSub?.cancel();
    deviceStateSub?.cancel();
    notifySub?.cancel();
    if (targetDevice != null && isConnected) {
      try {
        targetDevice!.disconnect();
      } catch (_) {}
    }
    super.dispose();
  }

  // ------------------ FLUXO PRINCIPAL ------------------
  Future<void> _ensureConnectedFlow() async {
    final ok = await _requestPermissions();
    if (!ok) {
      await _showAlert("Permiss√µes", "Permiss√µes necess√°rias n√£o concedidas. O app n√£o funcionar√° corretamente.");
      return;
    }

    final btOn = await _isBluetoothOn();
    if (!btOn) {
      final result = await _showConfirm("Bluetooth desligado", "O Bluetooth est√° desligado. Deseja ativ√°-lo?");
      if (result == true) {
        try {
          await FlutterBluePlus.turnOn();
        } catch (_) {}
      }
      return;
    }

    await _tryConnectWithRetries();
  }

  // ------------------ PERMISS√ïES ------------------
  Future<bool> _requestPermissions() async {
    try {
      final toRequest = <Permission>[
        Permission.bluetoothScan,
        Permission.bluetoothConnect,
        Permission.bluetooth,
        Permission.locationWhenInUse,
        Permission.location,
      ];

      final statuses = await toRequest.request();

      for (var p in toRequest) {
        final s = statuses[p];
        if (s == null) continue;
        if (s.isDenied || s.isPermanentlyDenied || s.isRestricted) {
          print("‚ùå Permiss√£o negada: $p");
          return false;
        }
      }
      return true;
    } catch (e) {
      print("Erro ao solicitar permiss√µes: $e");
      return false;
    }
  }

  // ------------------ CHECAR BLUETOOTH ------------------
  Future<bool> _isBluetoothOn() async {
    try {
      final state = await FlutterBluePlus.adapterState.first;
      print("üì° Estado do Bluetooth: $state");
      return state == BluetoothAdapterState.on;
    } catch (e) {
      print("Erro ao verificar estado bluetooth: $e");
      return false;
    }
  }

  // ------------------ TENTATIVAS DE CONEX√ÉO ------------------
  Future<void> _tryConnectWithRetries() async {
    int attempt = 0;
    while (attempt < maxRetries && !isConnected) {
      attempt++;
      print("Tentativa $attempt / $maxRetries");
      final found = await _startScanAndConnect(timeout: Duration(seconds: scanTimeoutSeconds));
      if (found && isConnected) {
        print("‚úÖ Conectado na tentativa $attempt");
        return;
      } else {
        final again = await _showConfirm("EDUCARE n√£o encontrado", "Deseja tentar novamente? (Tentativa $attempt/$maxRetries)");
        if (again != true) return;
      }
    }

    if (!isConnected) {
      await _showAlert("Falha", "N√£o foi poss√≠vel conectar ao EDUCARE ap√≥s $maxRetries tentativas.");
    }
  }

  Future<bool> _startScanAndConnect({required Duration timeout}) async {
    try {
      await FlutterBluePlus.stopScan();
    } catch (_) {}

    bool deviceFound = false;
    scanning = true;
    setState(() {});

    final completer = Completer<bool>();

    try {
      FlutterBluePlus.startScan(timeout: timeout);

      scanResultsSub = FlutterBluePlus.scanResults.listen((results) async {
        for (final r in results) {
          final name = r.device.name;
          print("üîç Scan: $name (${r.device.id})");
          if (name == deviceName) {
            deviceFound = true;
            await FlutterBluePlus.stopScan();
            await scanResultsSub?.cancel();
            targetDevice = r.device;
            final connected = await _connectToDevice();
            if (!completer.isCompleted) completer.complete(connected);
            break;
          }
        }
      });

      FlutterBluePlus.isScanning.listen((isScanning) {
        if (!isScanning && !deviceFound && !completer.isCompleted) {
          completer.complete(false);
        }
      });

      final result = await completer.future.timeout(timeout + const Duration(seconds: 2), onTimeout: () {
        if (!completer.isCompleted) completer.complete(false);
        return false;
      });

      return result;
    } catch (e) {
      print("Erro no scan: $e");
      if (!completer.isCompleted) completer.complete(false);
      return false;
    } finally {
      scanning = false;
      setState(() {});
    }
  }

  // ------------------ CONEX√ÉO E NOTIFICA√á√ïES ------------------
  Future<bool> _connectToDevice() async {
    if (targetDevice == null) return false;

    try {
      final st = await targetDevice!.connectionState.first;
      if (st == BluetoothConnectionState.connected) {
        isConnected = true;
        print("‚ôªÔ∏è J√° conectado.");
      } else {
        await targetDevice!.connect(timeout: const Duration(seconds: 10));
        isConnected = true;
        print("‚úÖ Conectado a ${targetDevice!.name}");
      }

      deviceStateSub?.cancel();
      deviceStateSub = targetDevice!.connectionState.listen((state) {
        print("üîå Estado do dispositivo: $state");
        if (state == BluetoothConnectionState.disconnected) {
          isConnected = false;
          targetCharacteristic = null;
          _showConfirm("Conex√£o perdida", "Reconectar ao EDUCARE?").then((retry) {
            if (retry == true) _ensureConnectedFlow();
          });
        }
      });

      final services = await targetDevice!.discoverServices();
      print("üìÇ Servi√ßos: ${services.length}");

      BluetoothCharacteristic? found;
      for (var s in services) {
        for (var c in s.characteristics) {
          if (c.properties.notify || c.properties.read || c.properties.write) {
            found = c;
            break;
          }
        }
        if (found != null) break;
      }

      if (found == null) {
        print("‚ö†Ô∏è Caracter√≠stica n√£o encontrada.");
        return true; // conectado mas sem caracter√≠stica
      }

      targetCharacteristic = found;

      if (targetCharacteristic!.properties.notify) {
        await targetCharacteristic!.setNotifyValue(true);
        notifySub?.cancel();
        notifySub = targetCharacteristic!.value.listen((value) {
          if (value.isEmpty) return;
          print("üì• Raw: $value");
          try {
            final letra = utf8.decode(value).trim();
            print("üì• Recebido: '$letra'");
            setState(() => received = letra);
          } catch (e) {
            print("Erro decode: $e");
          }
        });
      }

      return true;
    } catch (e) {
      print("‚ùå Erro conectar: $e");
      isConnected = false;
      return false;
    }
  }

  // ------------------ UI HELPERS ------------------
  Future<void> _showAlert(String title, String message) async {
    if (!mounted) return;
    await showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(title),
        content: Text(message),
        actions: [TextButton(onPressed: () => Navigator.pop(context), child: const Text("OK"))],
      ),
    );
  }

  Future<bool?> _showConfirm(String title, String message) async {
    if (!mounted) return false;
    return showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(title),
        content: Text(message),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text("Cancelar")),
          ElevatedButton(onPressed: () => Navigator.pop(context, true), child: const Text("Sim")),
        ],
      ),
    );
  }

  Future<bool> _ensureConnectionBeforeAction() async {
    if (isConnected && targetDevice != null) return true;
    final retry = await _showConfirm("Sem conex√£o", "Deseja reconectar ao EDUCARE?");
    if (retry == true) {
      await _ensureConnectedFlow();
      return isConnected;
    }
    return false;
  }

  // ------------------ BOT√ïES ------------------
  Widget _buildButton(String letra) {
    final ativo = received == letra;
    return ElevatedButton(
      onPressed: () async {
        final ok = await _ensureConnectionBeforeAction();
        if (!ok) return;

        if (targetCharacteristic != null && targetCharacteristic!.properties.write) {
          try {
            final bytes = utf8.encode(letra);
            await targetCharacteristic!.write(bytes);
            print("‚û° Enviado: $letra");
          } catch (e) {
            print("Erro enviar: $e");
            await _showAlert("Erro", "Falha ao enviar comando: $e");
          }
        } else {
          print("‚ö†Ô∏è Caracter√≠stica n√£o suporta escrita.");
        }
      },
      style: ElevatedButton.styleFrom(
        backgroundColor: ativo ? Colors.green : Colors.grey,
        minimumSize: const Size(120, 48),
      ),
      child: Text("Bot√£o $letra"),
    );
  }

  @override
  Widget build(BuildContext context) => Scaffold(
        appBar: AppBar(title: const Text("Controle EDUCARE")),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              _buildButton("A"),
              _buildButton("E"),
              _buildButton("I"),
              _buildButton("O"),
              _buildButton("U"),
              const SizedBox(height: 24),
              Text("√öltimo recebido: $received"),
              const SizedBox(height: 12),
              Text("Status: ${isConnected ? 'Conectado' : (scanning ? 'Procurando...' : 'Desconectado')}"),
              const SizedBox(height: 8),
              ElevatedButton(
                onPressed: () async {
                  await _ensureConnectedFlow();
                },
                child: const Text("Conectar / Reconectar"),
              )
            ],
          ),
        ),
      );
}
